<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS Arena</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #1a1a1a; color: white; overflow: hidden; }
        #gameContainer { width: 100vw; height: 100vh; position: relative; }
        #menuScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a1a1a, #2d2d2d);
            display: flex; align-items: center; justify-content: center;
            flex-direction: column; z-index: 1000;
        }
        #gameOverScreen, #victoryScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; align-items: center; justify-content: center; flex-direction: column; z-index: 1000;
        }
        #gameOverScreen { background: rgba(0,0,0,0.9);}
        #victoryScreen { background: linear-gradient(135deg, #ffd700, #ff8c00);}
        .title { font-size: 4rem; font-weight: bold; margin-bottom: 2rem; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);}
        .subtitle { font-size: 1.5rem; margin-bottom: 2rem;}
        .button {
            padding: 1rem 2rem; font-size: 1.2rem; font-weight: bold;
            background: #dc2626; color: white; border: none; border-radius: 8px;
            cursor: pointer; transition: background 0.3s; margin: 0.5rem;
        }
        .button:hover { background: #b91c1c; }
        .button.secondary { background: #2563eb; }
        .button.secondary:hover { background: #1d4ed8; }
        #hud {
            position: absolute; top: 20px; left: 20px; z-index: 100;
        }
        .hud-item {
            background: rgba(0, 0, 0, 0.7); padding: 10px 15px;
            margin-bottom: 10px; border-radius: 5px; font-size: 1.2rem; font-weight: bold;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 20px; height: 20px; border: 2px solid white;
            border-radius: 50%; opacity: 0.7; z-index: 50;
        }
        #instructions {
            position: absolute; bottom: 20px; left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px; border-radius: 5px; font-size: 0.9rem; z-index: 50;
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Menu Principal -->
    <div id="menuScreen">
    <h1 class="title" style="color: #dc2626;">FPS ARENA</h1>
    <p class="subtitle">Affrontez 24 ennemis de 8 types diff√©rents avec vos personnages custom !</p>
    <div style="margin-bottom: 2rem;">
        <button class="button" onclick="startGame()">üéÆ COMMENCER LA BATAILLE</button>
    </div>
    <div style="margin-bottom: 2rem;">
        <h3 style="margin-bottom: 1rem;">Contr√¥les :</h3>
        <p style="font-size: 0.9rem;">WASD - D√©placement | Souris - Regarder | Clic gauche - Tirer | ESPACE/SHIFT - Monter/Descendre</p>
    </div>
</div>
        
        <!-- √âcran Game Over -->
        <div id="gameOverScreen">
            <h1 class="title" style="color: #dc2626;">GAME OVER</h1>
            <p class="subtitle">Score final: <span id="finalScore">0</span></p>
            <p style="margin-bottom: 2rem;">Vous avez √©t√© √©limin√© par les ennemis !</p>
            <button class="button" onclick="restartGame()">REJOUER</button>
        </div>
        
        <!-- √âcran Victoire -->
        <div id="victoryScreen">
            <h1 class="title" style="color: #ffd700;">VICTOIRE !</h1>
            <p class="subtitle">Score final: <span id="victoryScore">0</span></p>
            <p style="margin-bottom: 2rem;">Vous avez √©limin√© tous les ennemis !</p>
            <button class="button" onclick="restartGame()">NOUVELLE PARTIE</button>
        </div>
        
        <!-- HUD du jeu -->
        <div id="hud" class="hidden">
            <div class="hud-item">Score: <span id="scoreDisplay">0</span></div>
            <div class="hud-item">Vie: <span id="healthDisplay">100</span>/100</div>
            <div class="hud-item">Munitions: <span id="ammoDisplay">30</span>/30</div>
            <div class="hud-item">Ennemis: <span id="enemiesDisplay">24</span></div>
        </div>
        
        <!-- R√©ticule -->
        <div id="crosshair" class="hidden"></div>
        
        <!-- Instructions -->
        <div id="instructions" class="hidden">
            Cliquez pour verrouiller la souris ‚Ä¢ WASD pour bouger ‚Ä¢ Clic gauche pour tirer ‚Ä¢ ESPACE/SHIFT pour monter/descendre
        </div>
    </div>

    <script>
        // Variables globales
        let scene, camera, renderer, clock;
        let player = { x: 0, y: 1.8, z: 0 };
        let enemies = [];
        let bullets = [];
        let walls = [];
        let mouse = { x: 0, y: 0 };
        let keys = {};
        let isPointerLocked = false;
        let lastShot = 0;
        let gameState = {
            health: 100,
            ammo: 30,
            score: 0,
            enemiesLeft: 24,
            gameStarted: false,
            gameOver: false,
            victory: false
        };

        // Types d'ennemis avec chemins d'images locaux
        const enemyTypes = [
            { name: 'Artichaut', image: 'artichaut.png', health: 150, speed: 1, damage: 25, size: 3.5, color: 0x8fbc8f },
            { name: 'Brocoli', image: 'brocoli.png', health: 120, speed: 1.5, damage: 20, size: 3.2, color: 0x00ff00 },
            { name: 'Hydre', image: 'hydre.png', health: 300, speed: 0.8, damage: 40, size: 4.5, color: 0x9acd32 },
            { name: 'Loup', image: 'loup.png', health: 100, speed: 5, damage: 18, size: 2.8, color: 0x8b4513 },
            { name: 'Renard', image: 'renard.png', health: 80, speed: 4, damage: 15, size: 2.5, color: 0xff6600 },
            { name: 'Samoura√Ø', image: 'samourai.png', health: 180, speed: 3, damage: 35, size: 3, color: 0xdc143c },
            { name: 'Viking', image: 'viking.png', health: 200, speed: 2.5, damage: 30, size: 4, color: 0xdeb887 },
            { name: 'Zombie', image: 'zombie.png', health: 60, speed: 1, damage: 12, size: 2.7, color: 0x556b2f }
        ];

        // Charger image locale automatiquement
        function loadEnemyImage(enemyType) {
            return enemyType.image;
        }

        // Fonction simplifi√©e pour tester les images (console)
        function testImageAvailability() {
            console.log("=== TEST DES IMAGES ===");
            console.log("Placez vos fichiers dans le dossier du jeu :");
            enemyTypes.forEach(type => {
                const testImg = new Image();
                testImg.onload = () => { console.log(`‚úÖ ${type.image} ‚Üí OK`); };
                testImg.onerror = () => { console.log(`‚ùå ${type.image} ‚Üí Fichier NON TROUV√â`); };
                testImg.src = type.image + '?t=' + Date.now();
            });
        }

        // Fonction pour cr√©er un ennemi avec image automatique
        function createEnemyWithImage(enemyType, position) {
            // Cube par d√©faut
            const geometry = new THREE.BoxGeometry(2, enemyType.size, 2);
            const material = new THREE.MeshLambertMaterial({ color: enemyType.color, transparent: false });
            const enemy = new THREE.Mesh(geometry, material);
            enemy.castShadow = true;
            enemy.receiveShadow = true;
            enemy.position.copy(position);

            // Charger l'image locale
            const imageSource = loadEnemyImage(enemyType);
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                imageSource,
                // Succ√®s
                (texture) => {
                    texture.magFilter = THREE.NearestFilter;
                    texture.minFilter = THREE.NearestFilter;
                    const spriteMaterial = new THREE.SpriteMaterial({
                        map: texture, transparent: true, alphaTest: 0.1
                    });
                    const sprite = new THREE.Sprite(spriteMaterial);
                    sprite.scale.set(enemyType.size, enemyType.size, 1);
                    sprite.position.copy(enemy.position);
                    sprite.userData = enemy.userData;
                    // Remplacer le cube par le sprite
                    scene.remove(enemy);
                    scene.add(sprite);
                    const enemyIndex = enemies.indexOf(enemy);
                    if (enemyIndex !== -1) enemies[enemyIndex] = sprite;
                },
                undefined,
                // Erreur : on garde le cube
                (err) => { }
            );
            return enemy;
        }

        function restartGame() {
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'none';
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('crosshair').classList.add('hidden');
            document.getElementById('instructions').classList.add('hidden');
            document.getElementById('menuScreen').style.display = 'flex';

            // Nettoyer le renderer
            if (renderer && renderer.domElement && renderer.domElement.parentNode) {
                renderer.domElement.parentNode.removeChild(renderer.domElement);
            }

            // Nettoyer la sc√®ne
            if (scene) {
                while(scene.children.length > 0){ scene.remove(scene.children[0]); }
            }

            // Reset du jeu
            enemies = [];
            bullets = [];
            walls = [];
            gameState = {
                health: 100,
                ammo: 30,
                score: 0,
                enemiesLeft: 24,
                gameStarted: false,
                gameOver: false,
                victory: false
            };
            player = { x: 0, y: 1.8, z: 0 };
            mouse = { x: 0, y: 0 };
            keys = {};
            isPointerLocked = false;
        }

        // Initialisation du jeu
        function initGame() {
            // Cacher les menus
            document.getElementById('menuScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'none';
            // Afficher le HUD
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('crosshair').classList.remove('hidden');
            document.getElementById('instructions').classList.remove('hidden');

            gameState.gameStarted = true;
            gameState.gameOver = false;
            gameState.victory = false;

            // Reset des variables
            enemies = [];
            bullets = [];
            walls = [];
            player = { x: 0, y: 1.8, z: 0 };

            // Initialisation de Three.js
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Ciel bleu
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.8, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            const gameContainer = document.getElementById('gameContainer');
            gameContainer.appendChild(renderer.domElement);
            clock = new THREE.Clock();

            // Lumi√®res am√©lior√©es
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            scene.add(directionalLight);
            const pointLight = new THREE.PointLight(0xffffff, 0.5, 100);
            pointLight.position.set(0, 10, 0);
            scene.add(pointLight);

            createEnvironment();
            createEnemies();
            setupControls();
            updateHUD();

            setTimeout(() => { debugGame(); }, 1000);

            animate();
        }

        // Cr√©ation de l'environnement
        function createEnvironment() {
            const floorGeometry = new THREE.PlaneGeometry(100, 100);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x506050, transparent: false });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            floor.receiveShadow = true;
            scene.add(floor);

            const wallPositions = [
                { x: 0, z: -50, width: 100, height: 10, depth: 2 },
                { x: 0, z: 50, width: 100, height: 10, depth: 2 },
                { x: -50, z: 0, width: 2, height: 10, depth: 100 },
                { x: 50, z: 0, width: 2, height: 10, depth: 100 }
            ];
            wallPositions.forEach((wall) => {
                const geometry = new THREE.BoxGeometry(wall.width, wall.height, wall.depth);
                const material = new THREE.MeshLambertMaterial({ color: 0x8B4513, transparent: false });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(wall.x, wall.height/2, wall.z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
                walls.push(mesh);
            });

            const obstacleColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffa500, 0x800080, 0x008000, 0xffc0cb];
            for (let i = 0; i < 10; i++) {
                const geometry = new THREE.BoxGeometry(3, 6, 3);
                const material = new THREE.MeshLambertMaterial({ color: obstacleColors[i] || Math.random() * 0xffffff, transparent: false });
                const obstacle = new THREE.Mesh(geometry, material);
                const x = (Math.random() - 0.5) * 60;
                const z = (Math.random() - 0.5) * 60;
                obstacle.position.set(x, 3, z);
                obstacle.castShadow = true;
                obstacle.receiveShadow = true;
                scene.add(obstacle);
                walls.push(obstacle);
            }
            for (let i = 0; i < 4; i++) {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: false });
                const cube = new THREE.Mesh(geometry, material);
                const angle = (i / 4) * Math.PI * 2;
                const distance = 5;
                cube.position.set(Math.cos(angle) * distance, 0.5, Math.sin(angle) * distance);
                cube.castShadow = true;
                cube.receiveShadow = true;
                scene.add(cube);
            }
        }

        function createEnemies() {
            enemyTypes.forEach((enemyType) => {
                for (let i = 0; i < 3; i++) {
                    let x, z;
                    do {
                        x = (Math.random() - 0.5) * 60;
                        z = (Math.random() - 0.5) * 60;
                    } while (Math.sqrt(x*x + z*z) < 8);
                    const position = new THREE.Vector3(x, enemyType.size/2, z);
                    const enemy = createEnemyWithImage(enemyType, position);
                    enemy.userData = {
                        type: enemyType.name,
                        health: enemyType.health,
                        maxHealth: enemyType.health,
                        speed: enemyType.speed,
                        damage: enemyType.damage,
                        lastAttack: 0,
                        direction: new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize()
                    };
                    scene.add(enemy);
                    enemies.push(enemy);
                }
            });
            gameState.enemiesLeft = enemies.length;
        }

        function startGame() { initGame(); }

        function setupControls() {
            document.addEventListener('keydown', (event) => { keys[event.code] = true; });
            document.addEventListener('keyup', (event) => { keys[event.code] = false; });
            document.addEventListener('mousemove', (event) => {
                if (!isPointerLocked) return;
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                mouse.x -= movementX * 0.002;
                mouse.y -= movementY * 0.002;
                mouse.y = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouse.y));
                camera.rotation.order = 'YXZ';
                camera.rotation.y = mouse.x;
                camera.rotation.x = mouse.y;
            });
            document.addEventListener('mousedown', (event) => { if (event.button === 0) shoot(); });
            renderer.domElement.addEventListener('click', () => { renderer.domElement.requestPointerLock(); });
            document.addEventListener('pointerlockchange', () => { isPointerLocked = document.pointerLockElement === renderer.domElement; });
        }

        function shoot() {
            const now = Date.now();
            if (now - lastShot < 200 || gameState.ammo <= 0) return;
            lastShot = now;
            gameState.ammo--;
            updateHUD();
            const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            bullet.position.copy(camera.position);
            bullet.userData = {
                velocity: new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion).multiplyScalar(50),
                life: 100
            };
            scene.add(bullet);
            bullets.push(bullet);
        }

        function updatePlayer(delta) {
            const moveSpeed = 15;
            const direction = new THREE.Vector3();
            if (keys['KeyW']) direction.z -= 1;
            if (keys['KeyS']) direction.z += 1;
            if (keys['KeyA']) direction.x -= 1;
            if (keys['KeyD']) direction.x += 1;
            if (direction.length() > 0) {
                direction.normalize();
                const horizontalDirection = new THREE.Vector3(direction.x, 0, direction.z);
                horizontalDirection.applyQuaternion(camera.quaternion);
                horizontalDirection.y = 0;
                horizontalDirection.normalize();
                const newPosition = {
                    x: player.x + horizontalDirection.x * moveSpeed * delta,
                    y: player.y,
                    z: player.z + horizontalDirection.z * moveSpeed * delta
                };
                if (!checkCollisions(newPosition)) {
                    player.x = newPosition.x;
                    player.z = newPosition.z;
                }
            }
            if (keys['Space']) player.y = Math.min(20, player.y + moveSpeed * delta);
            if (keys['ShiftLeft']) player.y = Math.max(0.5, player.y - moveSpeed * delta);
            camera.position.set(player.x, player.y, player.z);
        }

        function checkCollisions(newPosition) {
            const playerBox = new THREE.Box3(
                new THREE.Vector3(newPosition.x - 0.5, 0, newPosition.z - 0.5),
                new THREE.Vector3(newPosition.x + 0.5, 2, newPosition.z + 0.5)
            );
            for (let wall of walls) {
                const wallBox = new THREE.Box3().setFromObject(wall);
                if (playerBox.intersectsBox(wallBox)) return true;
            }
            if (Math.abs(newPosition.x) > 48 || Math.abs(newPosition.z) > 48) return true;
            return false;
        }

        function updateEnemies(delta) {
            enemies.forEach((enemy, index) => {
                if (enemy.userData.health <= 0) {
                    scene.remove(enemy);
                    enemies.splice(index, 1);
                    let points = 10;
                    switch(enemy.userData.type) {
                        case 'Zombie': points = 5; break;
                        case 'Renard': points = 15; break;
                        case 'Loup': points = 20; break;
                        case 'Brocoli': points = 25; break;
                        case 'Artichaut': points = 30; break;
                        case 'Viking': points = 40; break;
                        case 'Samoura√Ø': points = 50; break;
                        case 'Hydre': points = 100; break;
                    }
                    gameState.score += points;
                    gameState.enemiesLeft = enemies.length;
                    updateHUD();
                    if (enemies.length === 0) {
                        gameState.victory = true;
                        showVictory();
                    }
                    return;
                }
                // IA simple
                const playerPos = new THREE.Vector3(player.x, 0, player.z);
                const enemyPos = new THREE.Vector3(enemy.position.x, 0, enemy.position.z);
                const direction = playerPos.sub(enemyPos).normalize();
                const newPos = enemy.position.clone();
                newPos.x += direction.x * enemy.userData.speed * delta;
                newPos.z += direction.z * enemy.userData.speed * delta;
                // Collision murs
                const enemyBox = new THREE.Box3(
                    new THREE.Vector3(newPos.x - 1, 0, newPos.z - 1),
                    new THREE.Vector3(newPos.x + 1, 3, newPos.z + 1)
                );
                let canMove = true;
                for (let wall of walls) {
                    const wallBox = new THREE.Box3().setFromObject(wall);
                    if (enemyBox.intersectsBox(wallBox)) {
                        canMove = false;
                        break;
                    }
                }
                if (canMove) {
                    enemy.position.x = newPos.x;
                    enemy.position.z = newPos.z;
                }
                // Attaque si proche
                const distToPlayer = enemy.position.distanceTo(new THREE.Vector3(player.x, enemy.position.y, player.z));
                if (distToPlayer < 3 && Date.now() - enemy.userData.lastAttack > 1000) {
                    enemy.userData.lastAttack = Date.now();
                    gameState.health -= enemy.userData.damage;
                    updateHUD();
                    if (enemy.material && enemy.material.color) {
                        enemy.material.color.setHex(0xff0000);
                        setTimeout(() => { if (enemy.material && enemy.material.color) enemy.material.color.setHex(0xffffff); }, 100);
                    }
                    if (gameState.health <= 0) {
                        gameState.gameOver = true;
                        showGameOver();
                    }
                }
            });
        }

        function updateBullets(delta) {
            bullets.forEach((bullet, index) => {
                bullet.position.add(bullet.userData.velocity.clone().multiplyScalar(delta));
                bullet.userData.life--;
                if (bullet.userData.life <= 0) {
                    scene.remove(bullet);
                    bullets.splice(index, 1);
                    return;
                }
                enemies.forEach(enemy => {
                    if (bullet.position.distanceTo(enemy.position) < 2) {
                        enemy.userData.health -= 50;
                        if (enemy.material && enemy.material.color) {
                            enemy.material.color.setHex(0xff8888);
                            setTimeout(() => { if (enemy.material && enemy.material.color) enemy.material.color.setHex(0xffffff); }, 100);
                        }
                        scene.remove(bullet);
                        bullets.splice(index, 1);
                    }
                });
                const bulletBox = new THREE.Box3().setFromObject(bullet);
                for (let wall of walls) {
                    const wallBox = new THREE.Box3().setFromObject(wall);
                    if (bulletBox.intersectsBox(wallBox)) {
                        scene.remove(bullet);
                        bullets.splice(index, 1);
                        break;
                    }
                }
            });
        }

        function autoReload() {
            if (gameState.ammo === 0) {
                setTimeout(() => {
                    gameState.ammo = 30;
                    updateHUD();
                }, 2000);
            }
        }

        function updateHUD() {
            document.getElementById('scoreDisplay').textContent = gameState.score;
            document.getElementById('healthDisplay').textContent = gameState.health;
            document.getElementById('ammoDisplay').textContent = gameState.ammo;
            document.getElementById('enemiesDisplay').textContent = gameState.enemiesLeft;
        }

        function showGameOver() {
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('gameOverScreen').style.display = 'flex';
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('crosshair').classList.add('hidden');
            document.getElementById('instructions').classList.add('hidden');
        }

        function showVictory() {
            document.getElementById('victoryScore').textContent = gameState.score;
            document.getElementById('victoryScreen').style.display = 'flex';
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('crosshair').classList.add('hidden');
            document.getElementById('instructions').classList.add('hidden');
        }

        function animate() {
            if (gameState.gameOver || gameState.victory) return;
            requestAnimationFrame(animate);
            if (!renderer || !scene || !camera) return;
            const delta = clock.getDelta();
            updatePlayer(delta);
            updateEnemies(delta);
            updateBullets(delta);
            autoReload();
            try { renderer.render(scene, camera); } catch (error) { }
        }

        function debugGame() {
            console.log("Scene:", scene);
            console.log("Camera:", camera);
            console.log("Renderer:", renderer);
            console.log("Enemies:", enemies.length);
            console.log("Player position:", player);
        }
        window.debugGame = debugGame;

        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>
